###############################################################################
# Verison: v2.1.0
# Author:  xflm
# Date:    Fri Feb 26 17:03:14 CST 2021
###############################################################################

###############################################################################
# Help notes
help:
ifeq ($(findstring zh, $(LANG)),)
	@echo -e \
"$(PRINT_BOLD)Usage:$(PRINT_COLOR_OFF) make [all(default) clean clone create debug files help qt slim tags]\n\
$(PRINT_BOLD)-- all:$(PRINT_COLOR_OFF)\n\
\tDefault action, compile the whole project, build the object file\n\
$(PRINT_BOLD)-- clean:$(PRINT_COLOR_OFF)\n\
\tClear the target file and all intermediate files. The implementation here is to delete the \"build/\" directory\n\
$(PRINT_BOLD)-- clone:$(PRINT_COLOR_OFF)\n\
\tCopy a new project, the new project will have all the files managed by the original project, those files that are not involved in the compilation will not be copied, and those files outside the project directory will be copied into the directory. Recursion will be performed in multiple make projects, and the files managed by each make will be copied into independent projects. If the top-level make uses the static library of the sub-make, the project copied by the top-level make only contains the corresponding static library and header Files, excluding source code files. The newly copied directory is \"../xx-clone\", \"xx\" is the target name of each make\n\
$(PRINT_BOLD)-- create:$(PRINT_COLOR_OFF)\n\
\tCall \"create.sh\" to construct the project, use \"make create DIR=xx\" to set search file path. See [Notes:1]\n\
$(PRINT_BOLD)-- debug:$(PRINT_COLOR_OFF)\n\
\tCalling GDB command debugger \"xx-gdb -q [object file]\" is only valid when compiling \"elf\" and \"exe\", and \"lib\" does not support debugging\n\
$(PRINT_BOLD)-- files:$(PRINT_COLOR_OFF)\n\
\tPrint files which are managed by make. When the project is not compiled, all the header files in the header file path will be printed. After compilation, only the header files involved in the compilation will be printed. It supports recursive execution in multiple make projects, and the list of files used in the compilation of each make will be printed respectively\n\
$(PRINT_BOLD)-- help:$(PRINT_COLOR_OFF)\n\
\tPrint this message\n\
$(PRINT_BOLD)-- qt:$(PRINT_COLOR_OFF)\n\
\tCreating the project file \".qt/*.pro\" of qtreactor will create at least two files, one of which is fixed as \".qt/all.pro\", it contains all the files of the project management, and other \".qt/xx.pro\" corresponding to the files managed by each make, \"xx\" is the target name of each make, and several \".qt/xx.pro\" will be generated when the project uses make several times. You can use QT to open any \".qt/*.pro\". You can execute \"make qt\" to update the pro file when QT is running. When the project is not compiled, the generated pro file contains all the header files in the header file path. After compilation, only the header files involved in the compilation are included\n\
$(PRINT_BOLD)-- slim:$(PRINT_COLOR_OFF)\n\
\tThin the project, that is, delete the unused C files from file.mk. Before modifying file.mk, back up all file.mk to the \"make_slim_bak/\" directory, and execute \"./make_slim_bak/recover.sh\" to restore Modify the previous state. \"make slim\" only modifies file.mk without deleting the source file. You can copy a new project by \"make clone\", so that the source code is not exist in the new project. This function does not apply to source code that is designated to be compiled into a static library\n\
$(PRINT_BOLD)-- tags:$(PRINT_COLOR_OFF)\n\
\tCall \"ctags\" command to create tag file, which covers all the files involved in compilation. It is different from \"ctags -R\", example it not tag a header file which is not used by any C file, although it in the path which writes in file.mk. It supports tagging files outside the project directory. It supports recursive execution in multiple make projects, and finally appends them to the \"tags\" file with \"ctags - a\"\n\
$(PRINT_BOLD)Notes:$(PRINT_COLOR_OFF)\n\
\t$(PRINT_BOLD)1)$(PRINT_COLOR_OFF) \"./tools/shell/create.sh\" This script can be used to construct the project, that is, to assist in generating the file.mk, the current directory is the project directory by default, and then the file.mk, source file and header file are searched, file.mk can be empty, at least there is a file.mk in the project directory, and other directories can be added as needed. Before the project is created, all file.mk files will be backed up to \"make_create_bak/*\", execute \"./make_create_bak/recover.sh\" to restore the state before modification. If you need to search for files outside the directory, you can pass the files outside the directory as a parameter to \"create.sh\". Absolute path and relative path are supported. The file.mk generated by these two paths will be somewhat different, and the absolute path and relative path will also be used during compilation. In addition, source files only support \".c .S\", header files only support \".h\"\n\
\t$(PRINT_BOLD)2)$(PRINT_COLOR_OFF) The \".gdbinit\" file depends on the \"Makefile\". If the Makefile is modified, make will modify the file name following the \"file\" command (related to TARGET); \"set \$$debug_in_rom = xx\" (related to RUN_TYPE); \"source ./xx/tools/gdb/*\"(related to TEMPLATE)\n\
\t$(PRINT_BOLD)3)$(PRINT_COLOR_OFF) make will execute the command string defined by \"CMD_BEFORE\" before the compilation starts, and execute the command string defined by \"CMD_AFTER\" after the compilation is completed \n\
\t$(PRINT_BOLD)4)$(PRINT_COLOR_OFF) If you modify the makefile, it is recommended to execute \"make clean; make\" (depending on the modified content)\n\
\t$(PRINT_BOLD)5)$(PRINT_COLOR_OFF) If you modify the link script, make will perform the relink\n\
\t$(PRINT_BOLD)6)$(PRINT_COLOR_OFF) If \"VPATH_MODE = y\", the intermediate files compiled by make are all in the same directory \"build/.obj/*\". In this case, files with the same name are not supported. If the \"VPATH_MODE = (empty)\", the intermediate file compiled by make is related to the source code path. It supports the compilation of files with the same name, but it is not friendly to files outside the compilation directory\n\
\t$(PRINT_BOLD)7)$(PRINT_COLOR_OFF) If \"LIB_NAME := (not empty)\" in the subdirectory file.mk make will compile the files managed by the file.mk into a static library, and finally link the static library to elf. If you need to use sub-make to compile the static library, copy \"tools/make/makefile\" to the directory where file.mk is located. \"tools/make/makefile\" uses the compilation parameters of the top-level make by default, and users can modify it to different parameters\n\
\t$(PRINT_BOLD)8)$(PRINT_COLOR_OFF) Execute \"make help LANG=zh\" to see the introduction in Chinese\n\
===== version: v2.0.0 author: xflm date: Sat Dec 19 09:11:46 CST 2020 ======"
else
	@echo -e \
"$(PRINT_BOLD)使用：$(PRINT_COLOR_OFF) make [all(default) clean clone create debug files help qt slim tags]\n\
$(PRINT_BOLD)-- all:$(PRINT_COLOR_OFF)\n\
\tmake默认动作，编译整个工程，构建目标文件\n\
$(PRINT_BOLD)-- clean:$(PRINT_COLOR_OFF)\n\
\t清除目标文件及所有中间文件，此处实现为删除“build/”目录\n\
$(PRINT_BOLD)-- clone:$(PRINT_COLOR_OFF)\n\
\t拷贝一个新工程，新工程会拥有原有工程管理的所有文件，那些不参与编译的文件不会被拷贝，那些工程目录之外的文件会拷贝到目录内部。在多次make的工程中会进行递归，分别把各个make管理的文件拷贝成独立的工程，若顶层make使用了子make的静态库，则顶层make拷贝的工程中仅包含相应的静态库和头文件，不包括源码文件。新拷贝的目录为“../xx-clone”，“xx”为各个make的目标名\n\
$(PRINT_BOLD)-- create:$(PRINT_COLOR_OFF)\n\
\t调用“create.sh”构建工程，使用“make create DIR=xx”设置文件搜索的路径，详细参考【补充：1】\n\
$(PRINT_BOLD)-- debug:$(PRINT_COLOR_OFF)\n\
\t调用GDB命令调试程序“xx-gdb -q 目标文件”，仅在编译“elf”和“exe”时有效，“lib”不支持调试\n\
$(PRINT_BOLD)-- files:$(PRINT_COLOR_OFF)\n\
\t打印file.mk管理的文件列表。工程未编译时，会打印所有头文件路径下的头文件，编译后，仅打印参与编译的头文件。在多次make的工程中会进行递归，分别打印各个make编译时使用的文件列表\n\
$(PRINT_BOLD)-- help:$(PRINT_COLOR_OFF)\n\
\t打印该说明内容\n\
$(PRINT_BOLD)-- qt:$(PRINT_COLOR_OFF)\n\
\t创建Qtcreator的工程文件“.qt/*.pro”，至少会创建两个文件，其中一个固定为“.qt/all.pro”里面保存了该工程管理的所有文件，其他“.qt/xx.pro”分别对应各个make管理的文件，“xx”为各个make的目标名，工程使用几次make就会有几个“.qt/xx.pro”。可以使用Qt打开任何一个“.qt/*.pro”，可以在Qt运行的过程中执行“make qt”更新pro文件。在工程未编译时，生成的pro文件包含所有头文件路径下的头文件，编译后，仅包含参与编译的头文件\n\
$(PRINT_BOLD)-- slim:$(PRINT_COLOR_OFF)\n\
\t工程瘦身，即把不使用的C文件从file.mk中删除，修改file.mk前会将所有file.mk备份至“make_slim_bak/”目录下，执行“./make_slim_bak/recover.sh”即可恢复修改之前的状态。“make slim”仅修改file.mk不删除源码文件，可以通过“make clone”拷贝一个新的工程，这样源码就“删除”了。该功能不适用于被指定编译成静态库的源码\n\
$(PRINT_BOLD)-- tags:$(PRINT_COLOR_OFF)\n\
\t调用“ctags”命令制作标签文件“tags”，涵盖所有参与编译的文件。它不同于“ctags -R”：在工程未编译时，它对所有头文件路径下的头文件及file.mk中管理的源码文件打标签；工程编译后，它仅对所有参与编译的文件打标签，未参与编译的头文件不会被打标签。它支持对工程目录以外的文件打标签，在多次make的工程中会进行递归，最终使用“ctags -a”追加到“tags”这个文件中\n\
$(PRINT_BOLD)补充：$(PRINT_COLOR_OFF)\n\
\t$(PRINT_BOLD)1)$(PRINT_COLOR_OFF) “./tools/shell/create.sh”该脚本可用于构造工程，即辅助生成file.mk文件，默认以当前目录为工程目录，进而搜索file.mk文件、源码文件和头文件，file.mk文件可以为空，至少在工程目录下有一个file.mk文件，其他目录可根据需要进行添加。工程创建前会备份所有的file.mk文件到“make_create_bak/*”,执行“./make_create_bak/recover.sh”可以恢复修改前的状态。若需搜索目录外的文件，可以把目录外的文件作为参数传递给“create.sh”，支持绝对路径和相对路径，这两种路径生成的file.mk会有些差异，编译时也会对应使用绝对路径和相对路径。另外，源码文件仅支持“.c .S”，头文件仅支持“.h”\n\
\t$(PRINT_BOLD)2)$(PRINT_COLOR_OFF) “.gdbinit”文件依赖于“Makefile”，如果Makefile被修改，则make会修改.gdbinit中：“file”命令后面的文件名（与TARGET有关）；“set \$$debug_in_rom = xx”（与RUN_TYPE有关）；“source ./xx/tools/gdb/*”（与TEMPLATE有关）\n\
\t$(PRINT_BOLD)3)$(PRINT_COLOR_OFF) make会在编译开始前执行“CMD_BEFORE”定义的命令串，在编译完成后执行“CMD_AFTER”定义的命令串\n\
\t$(PRINT_BOLD)4)$(PRINT_COLOR_OFF) 如果修改makefile文件，推荐执行“make clean;make”（根据修改内容而定）\n\
\t$(PRINT_BOLD)5)$(PRINT_COLOR_OFF) 如果修改了链接脚本，make会执行重新链接\n\
\t$(PRINT_BOLD)6)$(PRINT_COLOR_OFF) 如果“VPATH_MODE = y”，make编译的中间文件都在相同的目录“build/.obj/*”，该情况下不支持编译同名文件。如果“VPATH_MODE = （空）”make编译的中间文件和源码路径有关，支持编译同名文件，但对编译目录外的文件不友好\n\
\t$(PRINT_BOLD)7)$(PRINT_COLOR_OFF) 如果子file.mk中“LIB_NAME :=（非空）” make会把该file.mk管理的文件编译成静态库，最后把静态库拿去链接elf，若需要使用子make编译静态库，把“tools/make/makefile”拷贝到file.mk所在目录即可，“tools/make/makefile”默认延用顶层make的编译参数，用户可以修改为不同的参数\n\
\t$(PRINT_BOLD)8)$(PRINT_COLOR_OFF) 执行“make help LANG=en”，查看英文介绍\n\
===== 版本: v2.0.0 作者: 幸福留名 时间: 星期六 12月19日 09:11:46 CST 2020 ======"
endif
